package org.example.leetcode.lang.tree;

/**
 * https://developer.aliyun.com/lesson_1012_9035#_9035
 * <p>
 * 二叉树；
 * 二叉平衡树：左子树和右子树都是平衡二叉树，所有节点高度之差不超过 1；
 * 红黑树，二叉平衡树基础上，节点上增加红、黑标识。
 * <p>
 * 红黑树的特点：
 * 1、每个节点或者是黑色、或者是红色；
 * 2、根节点必须是黑色；
 * 3、每个叶子节点是黑色
 * （Java 实现的红黑树将使用 null 来代表空节点，
 * 因此，遍历红黑树时将看不到黑色的叶子节点，
 * 反而看到每个叶子节点都是红色的）；
 * 4、如果一个节点是红色的，那么它的子节点必须是黑色的
 * （从每个根到节点的路径上不会有两个连续的红色节点，但黑色节点可以是连续的。
 * 若给定黑色节点的个数 N，最短路径情况是连续的 N 个黑色，树的高度为 N-1，
 * 最长路径的情况为节点红黑相间，树的高度为 2(N-1)。）；
 * 5、从一个节点到该节点的子孙节点的所有路径上包含相同数目黑节点的数量
 * （是成为红黑树的最主要条件，后续的插入、删除操作都是为了遵守这个规定）。
 * <p>
 * 数据插入修复：
 * 1、新插入的节点默认都是红色的；
 * 2、第一次插入，由于原树为空，所以指挥违反红黑树的规则2，
 * 所以只要把根节点涂黑即可；
 * 3、如果插入节点的父节点是黑色的，那不会违背红黑树的规则，什么也不需要做；
 * 4、如果遇到如下三种情况时，就要开始变色和旋转了：
 * 4.1、插入节点的父节点和其叔叔节点均为红色的（右旋）；
 * 4.2、插入节点的父节点是红色，叔叔节点是黑色，
 * 且插入节点是其父节点的左子节点（涂反+右旋）；
 * 4.3、插入节点的父节点是红色，叔叔节点是黑色，
 * 且插入节点是其父节点的右子节点（左旋+涂反+右旋）。
 * <p>
 * 数据删除修复：
 * 1、删除操作后，如果当前节点是黑色的根节点，那么不用任何操作，
 * 因为并没有破坏树的平衡性，即：没有违背红黑树的规则；
 * 2、如果当前节点是红色的，说明刚刚移走的后继节点是黑色的，
 * 那么不管后继节点的父节点是啥颜色，
 * 只要将当前节点涂黑就可以了，红黑树的平衡性就可以恢复；
 * 3、但是如果遇到以下四种情况，就需要通过变色和旋转来恢复红黑树的平衡了：
 * 3.1、当前节点是黑色的，且兄弟节点是红色的
 * （那么父节点和兄弟节点的字节肯定是黑色的）；
 * 3.2、当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的；
 * 3.3、当前节点是黑色的，且兄弟节点是黑色的，
 * 且兄弟节点的左子节点是红色，右子节点是黑色的；
 * 3.4、当前节点是黑色的，且兄弟节点是黑色的，
 * 且兄弟节点的右子节点是黑色，左子节点是任意颜色。
 *
 * @author lifei
 */
public class RedBlackTree<T extends Comparable<T>> {
    private class Node {
        private final T data;
        private Node left;
        private Node right;
        private Node parent;
        private Color color;

        public Node(T data) {
            this.data = data;
        }
    }

    public static void main(String[] args) {
    }
}
